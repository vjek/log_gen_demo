#!/usr/bin/env python3
# sample mmo parsing gui
# functional, 20190209.  Start sinks button, again raises it, returns back to GUI for exit.
# also has summation of all damage, ongoing, and prints it in the gui window, crudely.
# updates for each second, then clears and starts again.
# fixed spaces in regex on 20190322
# reads from outfile1.txt, which should be generated by log_gen_generator
# usage would be to place both scripts in the same folder/directory, then 
# ./log_gen_generator_1.py > outfile1.txt &
# and then ./log_gen_gui_1.py and then click "Start monitoring log file"
###
from tkinter import *
from tkinter import font
import tkinter
import os
import time
import datetime
import re

#
# this is here as the exit action on the top window
def exit_action():
    exit()
#
# another button to clear the text area
def clear_buffer():
    tex.delete('1.0', END) #clear the buffer, as we're starting over.
    return

# log generator format:
###
# time_str = ('%02d%02d%02d.%03d'%(now.hour,now.minute,now.second,now.microsecond/1000))
# logline="{}{} {} {} a {} for {} {}{} damage."\
# .format(date_str,time_str,char_name,action,target,attack_type,dmg_val,crit_str,dmg_type)

def log_parse(logline):
#the following line matches all the fields from the log and assigns them to an re.match result.
    logline_re = re.compile('^(?P<date_str>\d{14})\.(?P<time_str>\d{3})\ (?P<char_name>\w+\ ?\w*)\ (?P<action>\w+)\ a\ (?P<target>\w+\ ?\w*)\ with\ (?P<attack_type>\w+\ ?\w*)\ for\ (?P<dmg_val>\d+)\ (?P<crit_str>critical)?\ ?(?P<dmg_type>\w+)\ damage\.$')
    log_fields = logline_re.match(logline) #assigns the dictionary fields, provided something was parsed.
    if log_fields is not None:
        date_str = log_fields.groupdict()['date_str']
        time_str = log_fields.groupdict()['time_str']
        char_name = log_fields.groupdict()['char_name']
        action = log_fields.groupdict()['action']
        target = log_fields.groupdict()['target']
        dmg_val = log_fields.groupdict()['dmg_val']
        crit_str = log_fields.groupdict()['crit_str']
        dmg_type = log_fields.groupdict()['dmg_type']
        attack_type = log_fields.groupdict()['attack_type']
#        print(log_fields.groupdict()) #comment or not to hide/show debug dictionary output
        print("%s|%s|%s|%s" % (char_name,target,dmg_val,crit_str))
        return(char_name,dmg_val) #could also just return log_fields dictionary completely
    else: #could also add several elifs here for multiple log line formats.
        print("Unparsed:",logline.rstrip())
    return

#
# this happens within the viewlogfile() function, and is here to check
# the logfile for new lines.  Ideally, it completes as quickly as possible
# so no update of the interface is required within it
#
def follow(thefile): # function to simply check if there are new lines
    global list_of_chars
    line = thefile.readline() # check for a new line
    if line: # if there's something, then
        parsed_values = log_parse(line)
        if parsed_values is not None:
            char_name,dmg_val = parsed_values
            dmg_val = int(dmg_val)
            char_exists = list_of_chars.setdefault(char_name,dmg_val)
            if char_exists != dmg_val: #if it was equal, it was just created
                list_of_chars[char_name] += dmg_val #add the value to the existing value
        yield line # return a line if there is one.
    return # otherwise just go back to the caller

#
# this happens when the start monitoring button is pressed.
# as a result, you need to update the display, or it will lock mainloop()
#    
def viewlogfile():
    global list_of_chars #ensure these vars are pulled into this context from their global states
    now = int(time.time()) #get current epoch time for future mark
    the_future = now + 1 #add one to it, so we can do something ~1 second later
# these two if/elses change the text and appearance of the button to show state
    if o.config('relief')[-1] == 'sunken':
        print("button is sunken, setting to raised")
        o.config(relief="raised",text="Start Monitoring log file")
        list_of_chars = {} #reset DPS counts for all characters
    else:
        print("button is raised, setting to sunken")
        o.config(relief="sunken",text="Stop Monitoring log file")
        list_of_chars = {} #reset DPS counts for all characters
# now it opens the logfile and tries to read from it.
    logfile = open("outfile1.txt","r")
    logfile.seek(0,2) # seek to the last byte in the file, first
    while logfile and o.config('relief')[-1] == 'sunken': # then, presuming the file is open and available..
        loglines = follow(logfile) # go and check if there are loglines to print
        for line in loglines: # if there are..
            tex.insert(END,sorted(list_of_chars.items(),key=lambda kv: kv[1],reverse=True)) # insert sorted map into the Text object
#            tex.insert(END,list_of_chars) # insert the unsorted map into the Text object
            tex.insert(END,"\n") #add carriage return so they don't run together.
#            tex.insert(END,line) # insert the log lines into the Text object
            tex.see(END) # move the cursor to the end of the Text object
            tex.update() # update the Text object (without this, nothing will display)
#            print(line, end='') # print the log lines to stdout in CLI, optionally

        now = int(time.time()) #update now for check
        if now >= the_future: #check now against future
            the_future = now + 1 # setup for the next second
            list_of_chars = {} #reset DPS counts for all characters
            tex.insert(END,"--------------------------------------------------") #add separator for timestamp
            tex.insert(END, time.strftime("%Y%m%d %H:%M:%S",time.localtime()) + "\n")
            tex.see(END) # move the cursor to the end of the Text object
            tex.update() # update the Text object (without this, nothing will display)
#        time.sleep(0.0001) # just sleep a bit so CPU usage isn't 100%
        time.sleep(0.001) # just sleep a bit so CPU usage isn't 100%
        tex.update() # update the Text object (without this, nothing will display)
    return

#start of sequential code
master = Tk()
root = tkinter.Tk()

#root.attributes("-topmost",True) #can use this to make the window always on top
master.withdraw()
root.title("Log Parser Demo")
root.lift()
#some global declarations for use across several functions
list_of_chars={} #this is the dictionary that gets populated every second containing character DPS
        
# create the window, with size/geometry.
#
x_offset = (root.winfo_screenwidth() - root.winfo_reqwidth()) / 2
y_offset = (root.winfo_screenheight() - root.winfo_reqheight()) / 20
x_size = 1000
y_size = 500
root.geometry("%dx%d+%d+%d" % (x_size, y_size, x_offset, y_offset))
if "PT Mono" in font.families(): #PT Mono is free from Google, then you get goldenrod
    tex = tkinter.Text(root, state=NORMAL, font = "{PT Mono} 9", bg="Black", fg="goldenrod1")
else: # otherwise, you get green
    tex = tkinter.Text(root, state=NORMAL, font = "{Courier New} 9", bg="Black", fg="#000fff000")
tex.pack(side=tkinter.BOTTOM,fill="both",expand=True)
#add scrollbar to text window
scroll_y = tkinter.Scrollbar(tex, orient="vertical", command=tex.yview, cursor="arrow")
scroll_y.pack(side="right", expand=False, fill="y")
tex.configure(yscrollcommand=scroll_y.set)

# create UI buttons, with associated functions to execute on press.
#
b = Button(root, text="Exit ", command=exit_action, fg="red")
c = Button(root, text="Clear buffer", command = clear_buffer, fg="brown")
o = Button(root, text="Start monitoring log file", command = viewlogfile)
b.pack(side=tkinter.RIGHT)
c.pack(side=tkinter.LEFT)
o.pack()

# start the main tkinter function, which draws everything and waits for updates
#
mainloop()
